// Code generated by sqlc. DO NOT EDIT.
// source: track.sql

package gen

import (
	"context"
	"database/sql"
)

const deleteTrackByUserIdAndId = `-- name: DeleteTrackByUserIdAndId :exec
delete from track where user_id = $1 and id = $2
`

type DeleteTrackByUserIdAndIdParams struct {
	UserID sql.NullInt32
	ID     sql.NullInt32
}

func (q *Queries) DeleteTrackByUserIdAndId(ctx context.Context, arg DeleteTrackByUserIdAndIdParams) error {
	_, err := q.db.ExecContext(ctx, deleteTrackByUserIdAndId, arg.UserID, arg.ID)
	return err
}

const getUserTracks = `-- name: GetUserTracks :many
select id, user_id, stock, market, board_group, security, tracked_volume, date, is_tracked from track where user_id = $1
`

func (q *Queries) GetUserTracks(ctx context.Context, userID sql.NullInt32) ([]Track, error) {
	rows, err := q.db.QueryContext(ctx, getUserTracks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Track
	for rows.Next() {
		var i Track
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Stock,
			&i.Market,
			&i.BoardGroup,
			&i.Security,
			&i.TrackedVolume,
			&i.Date,
			&i.IsTracked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveTrack = `-- name: SaveTrack :exec
insert into track (user_id, stock, market, board_group, security, date, tracked_volume) values (
    $1, $2, $3, $4, $5, $6, $7
)
`

type SaveTrackParams struct {
	UserID        sql.NullInt32
	Stock         string
	Market        string
	BoardGroup    int32
	Security      string
	Date          string
	TrackedVolume int32
}

func (q *Queries) SaveTrack(ctx context.Context, arg SaveTrackParams) error {
	_, err := q.db.ExecContext(ctx, saveTrack,
		arg.UserID,
		arg.Stock,
		arg.Market,
		arg.BoardGroup,
		arg.Security,
		arg.Date,
		arg.TrackedVolume,
	)
	return err
}

const trackSecurityByUserIdAndId = `-- name: TrackSecurityByUserIdAndId :exec
update track set is_tracked = true where user_id = $1 and id = $2
`

type TrackSecurityByUserIdAndIdParams struct {
	UserID sql.NullInt32
	ID     sql.NullInt32
}

func (q *Queries) TrackSecurityByUserIdAndId(ctx context.Context, arg TrackSecurityByUserIdAndIdParams) error {
	_, err := q.db.ExecContext(ctx, trackSecurityByUserIdAndId, arg.UserID, arg.ID)
	return err
}

const untrackSecurityByUserIdAndId = `-- name: UntrackSecurityByUserIdAndId :exec
update track set is_tracked = false where user_id = $1 and id = $2
`

type UntrackSecurityByUserIdAndIdParams struct {
	UserID sql.NullInt32
	ID     sql.NullInt32
}

func (q *Queries) UntrackSecurityByUserIdAndId(ctx context.Context, arg UntrackSecurityByUserIdAndIdParams) error {
	_, err := q.db.ExecContext(ctx, untrackSecurityByUserIdAndId, arg.UserID, arg.ID)
	return err
}
